#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_ARB_shader_clock : enable
#extension GL_EXT_scalar_block_layout : enable          // Usage of 'scalar' block layout

#extension GL_EXT_buffer_reference2 : require


#extension GL_EXT_nonuniform_qualifier : enable



#include "deviceDataStruct.h"
#include "globals.glsl"



#include "random.glsl"
#include "pathtrace.glsl"






void main() 
{
    // Initialize the random number
    ivec2 imageRes    = ivec2(gl_LaunchSizeEXT.xy);
    ivec2 imageCoords = ivec2(gl_LaunchIDEXT.xy);
    
    prd.seed = initRandom(gl_LaunchSizeEXT.xy, gl_LaunchIDEXT.xy, pcRay.frame);

    vec3 totalHitValues = vec3(0);
    
    
    for(int smpl = 0; smpl < pcRay.nbSample; smpl++)
    {

        
        totalHitValues += samplePixel(imageCoords, imageRes);
    
    }

    vec3 avgHitValue = totalHitValues / pcRay.nbSample;

    if( isnan(avgHitValue.r) || isnan(avgHitValue.g) || isnan(avgHitValue.b) ) {
        avgHitValue = vec3(1.0, 0.0, 0.0);
    }
    // Do accumulation over time 
    if(pcRay.frame > 0)
    {
        float a        = 1.0f / float(pcRay.frame + 1);
        vec3  oldColor = imageLoad(image, ivec2(gl_LaunchIDEXT.xy)).xyz;
        imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(mix(oldColor, avgHitValue, a), 1.f));
    }
    else 
    {
        // First frame, replace the value in the buffer
        imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(avgHitValue, 1.0));
    }


}
